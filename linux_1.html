---
layout: page
permalink: /Linux_1/
title: Linux_1
comments: true
---
<div id="header-wrapper">
	<div id="header" class="container">
		<div id="menu">
			<ul>
				<li><a href="{{ site.url }}" accesskey="1" title="Homepage">Homepage</a></li>
				<li class="active"><a href="{{ site.url }}Linux_1" accesskey="2" title="Linux_1">Linux_1</a></li>
				<li><a href="{{ site.url }}Linux_2" accesskey="3" title="Linux_2">Linux_2</a></li>
				<li><a href="{{ site.url }}Linux_3" accesskey="4" title="Linux_3">Linux_3</a></li>
				<li><a href="{{ site.url }}Linux_4" accesskey="5" title="Linux_4">Linux_4</a></li>
			</ul>
		</div>
	</div>
</div>

<div id="back1">
	<div class="wrapper">
		<div id="welcome" class="container">
    		<div class="title">
				<h2>Linux 1</h2>
				<h3>Shell</h3>
			</div>
			<p>To download codes, <a id="link1" href="{{ site.url }}#codes">CLICK HERE</a><a id="link2" href="#footer-small">CLICK HERE</a>! And here you can download <a href="https://raw.githubusercontent.com/MichaelTong/OSCourseDesign/master/reports/report1.pdf">Chinese Version</a>.</p>
		</div>
		<div id="index">
			<ul><a href="#C1"><strong><big>1 Requirements</big></strong></a></ul>
				<ul><a href="#C11"><b>1.1 Basic Functions</b></a></ul>
					<ul><a href="#C111"><small>1.1.1 Internal Commands</small></a></ul>
					<ul><a href="#C112"><small>1.1.2 Switch Between Front and Back Ends</small></a></ul>
					<ul><a href="#C113"><small>1.1.3 I/O Redirection</small></a></ul>
				<ul><a href="#C12"><b>1.2 Advanced Functions</b></a></ul>
					<ul><a href="#C121"><small>1.2.1 Pipe</small></a></ul>
					<ul><a href="#C122"><small>1.2.2 Wildcard</small></a></ul>
				<ul><a href="#C13"><b>1.3 Self-improved Functions</b></a></ul>
					<ul><a href="#C131"><small>1.3.1 Up and Down Keys</small></a></ul>
					<ul><a href="#C132"><small>1.3.2 Tab Key</small></a></ul>
					<ul><a href="#C133"><small>1.3.3 Backspace Key</small></a></ul>
					<ul><a href="#C134"><small>1.3.4 Improved Grammar</small></a></ul>
					<ul><a href="#C135"><small>1.3.5 Method of giving results of backend command</small></a></ul>
			<ul><a href="#C2"><strong><big>2 Design Description</big></strong></a></ul>
				<ul><a href="#C21"><b>2.1 Structure Design</b></a></ul>
					<ul><a href="#C211"><small>2.1.1 Grammar State Graph</small></a></ul>
					<ul><a href="#C212"><small>2.1.2 Program Structure Graph</small></a></ul>
					<ul><a href="#C213"><small>2.1.3 Terminal Control Procedure Graph</small></a></ul>
					<ul><a href="#C214"><small>2.1.4 Tab Making Up Procedure Graph</small></a></ul>
					<ul><a href="#C215"><small>2.1.5 Simple Commands Execution Procedure Graph</small></a></ul>
					<ul><a href="#C216"><small>2.1.6 Compond Commands Execution Procedure Graph</small></a></ul>
					<ul><a href="#C217"><small>2.1.7 Wildcard Procedure</small></a></ul>
					<ul><a href="#C218"><small>2.1.8 Use Case Graph</small></a></ul>	
				<ul><a href="#C22"><b>2.2 Function Design</b></a></ul>
					<ul><a href="#C221"><small>2.2.1 Important Data Structures</small></a></ul>
					<ul><a href="#C222"><small>2.2.2 Important Functions and Interfaces</small></a></ul>
					<ul><a href="#C223"><small>2.2.3 Funtion Call Graph</small></a></ul>
			<ul><a href="#C3"><strong><big>3. Test and Use Instruction</big></strong></a></ul>
					<ul><a href="#C31"><b>3.1 Use</b></a></ul>
					<ul><a href="#C32"><b>3.2 Test</b></a></ul>
		</div>
		<div id="doc">
			<h3 id="C1">1 Requirements</h3>
			<h4 id="C11">1.1 Basic Functions</h4>
			<p>This program give a command prompt with format <span class="grey">xsh@current_path></span>, such as <span class="grey">xsh@/home/tong/shell></span>, indicating that it is waiting for the user to input commands. After input, it will execute the command and output necessary information if the commands are correct, and then wait for the next command. Otherwise, it will print error information.</p>
			<h5 id="C111">1.1.1 Internal Commands</h5>
			<b>(1) exit</b>
			<p>Kill all sub processes and exit.</p>
			<b>(2) jobs</b>
			<p>Print jobs that are running in back end or suspended. The print format is</p> 
			<pre class="grey">INDEX		PID		STATE	  COMMAND</pre>
			<p>jobs is a internal command, it won't be printed on the screen.</p>
			<b>(3) history</b>
			<p>List the most recent HISTORY_LEN commands.</p>
			<b>(4) fg %<int></b>
			<p>Put a process identified with <int> in front end. The shell shouldn't print new information until this command ends.</p>
			<b>(5) bg %<int></b>
			<p>Put a suspended process to the back end and run.</p>
			<h5 id="C112">1.1.2 Switch Between Front and Back Ends</h5>
			<p>This program can execute front end jobs and back end jobs. The difference between these two is: shell has to wait until the front end job to end, while it should print prompt once starts executing back end jobs.</p>
			<p>When executing front end jobs, you should just give the path, but if it is back end job, you should add '&' sign at the end of the prompt.</p>
			<p>Besides, you can switch between front and back ends using:</p>
			<pre class="grey">Ctrl  +  Z</pre>
			<p>It will produce <span class="grey">SIGTSTP</span> signal. This signal won't suspend shell, but the shell suspends the front end job. If there is no front end job running, the combined keys won't take effects.</p>
			<p>Another combined keys:</p>
			<pre class="grey">Ctrl  +  C</pre>
			<p>will produce <span class="grey">SIGINT</span>signal. This signal won't terminate shell, but the shell will terminate any front end jobs. If there is no front end jobs running, the combined keys won't take effects.</p>			
			<h5 id="C113">1.1.3 I/O Redirection</h5>
			<p>There may be metacharacters '<' or '>' following a command. They indicate input or output redirections. There will be a file name following the redirection signs. If the output file does not exist, a new file will be created. If an input file does not exist, an error will occur.</p>

			<h4 id="C12">1.2 Advanced Functions</h4>
			<h5 id="C121">1.2.1 Pipe</h5>
			<p>When several commands are splitted by metacharacter '|', they can be placed in one command line. This metacharacter stands for pipe character. In this case, the shell will create a sub process or each sub commands, and it will link their I/O using pipes. This form of jobs will only end when all sub processes end.</p>
			<h5 id="C122">1.2.2 Wildcard</h5>
			<p>In this program, you can use wildcards '*' and '?' to match file or directory names. '*' indicates any string including empty string, and '?' indicates any single character.</p>
			<h4 id="C13">1.3 Self-improved Functions</h4>
			<h5 id="C131">1.3.1 Up and Down Arrows</h5>
			<p>Through I/O programming, the code for up and down arrows won't be displayed on the screen, instead it will scan through the history commands.</p>
			<h5 id="C132">1.3.2 Tab Key</h5>
			<p>Through I/O programming, the code for tab key won't be displayed on the screen. Instead, you can use tab key to make up command like real shells. If there are more that one commands that matach the head, all of the possible commands will be displayed with another hit on Tab key.</p>
			<h5 id="C133">1.3.3 Backspace Key</h5>
			<p>Through I/O programming, the code for backspace key won't be displayed on the screan. instead we implemented its delete function.</p>
			<h5 id="C134">1.3.4 Improved Grammar</h5>
			<p>The improved grammar provides support for wildcards and compond commands with pipes.</p>
			<h5 id="C135">1.3.5 Method of giving results of backend command</h5>
			<p>The results for back end command will not be printed until next hit on enter key after finished.</p>
			
			<h3 id="C2">2 Design Description</h3>
			<h4 id="C21">2.1 Structure Design</h4>
			<h5 id="C211">2.1.1 Grammar State Graph</h5>
			<b>(1) Command Line: line</b>
			<img src="{{ site.url }}images/linux_1/1.jpg"  alt="" />
			<br />
			
			<b>(2) Command: command</b>
			<img src="{{ site.url }}images/linux_1/2.jpg"  alt="" />
			<br />
			
			<b>(3) Front End Commands: fgCommand</b>
			<img src="{{ site.url }}images/linux_1/3.jpg"  alt="" />
			<br />
			
			<b>(4) Simple Commands: simpleCmd</b>
			<img src="{{ site.url }}images/linux_1/4.jpg"  alt="" />
			<br />
			
			<b>(5) Compond Commands: compondCmd</b>
			<img src="{{ site.url }}images/linux_1/5.jpg"  alt="" />
			<br />
			
			<b>(6) Next COmmand: nextCmd</b>
			<img src="{{ site.url }}images/linux_1/6.jpg"  alt="" />
			<br />
			
			<b>(7) Program Calls: ProgInvocation</b>
			<img src="{{ site.url }}images/linux_1/7.jpg"  alt="" />
			<br />
			
			<b>(8) Input Redirection: inputRedirect</b>
			<img src="{{ site.url }}images/linux_1/8.jpg"  alt="" />
			<br />
			
			<b>(9) Output Redirection: outputRedirect</b>
			<img src="{{ site.url }}images/linux_1/9.jpg"  alt="" />
			<br />
			
			<b>(10) Command Arguments: args</b>
			<img src="{{ site.url }}images/linux_1/10.jpg"  alt="" />
			<br />
			
			<b>(11) String: STR</b>
			<img src="{{ site.url }}images/linux_1/11.jpg"  alt="" />
			<br />
			
			<b>(12) Wildcards: rex</b>
			<img src="{{ site.url }}images/linux_1/12.jpg"  alt="" />
			<br />
			
			<h5 id="C212">2.1.2 Program Structure Graph</h5>
			<img src="{{ site.url }}images/linux_1/13.jpg"  alt="" />
			
			<h5 id="C213">2.1.3 Terminal Control Procedure Graph</h5>
			<img src="{{ site.url }}images/linux_1/14.jpg"  alt="" />
			
			<h5 id="C214">2.1.4 Tab Making Up Procedure Graph</h5>
			<img src="{{ site.url }}images/linux_1/15.jpg"  alt="" />
			
			<h5 id="C215">2.1.5 Simple Commands Execution Procedure Graph</h5>
			<img src="{{ site.url }}images/linux_1/16.jpg"  alt="" />
			
			<h5 id="C216">2.1.6 Compond Commands Execution Procedure Graph</h5>
			<img src="{{ site.url }}images/linux_1/17.jpg"  alt="" />
			
			<h5 id="C217">2.1.7 Wildcard Procedure</h5>
			<img src="{{ site.url }}images/linux_1/18.jpg"  alt="" />
			
			<h5 id="C218">2.1.8 Use Case Graph</h5>
			<img src="{{ site.url }}images/linux_1/19.jpg"  alt="" />
			
			
			<h4 id="C22">2.2 Function Design</h4>
			<h5 id="C221">2.2.1 Important Data Structures</h5>
<b>(1) Simple Command</b>
<pre class='grey'>
typedef struct SimpleCmd {
        int isBack;     // If in back end
        char **args;    // Command and arguments
        char *input;    // Input Redirection
        char *output;   // Output Redirection
    } SimpleCmd;
</pre>
<p>
Simple Command consists of four part.<br />
When isBack is 1, it indicates this command will be executed in back end, or in front end.<br />
**args stores command and its arguments. *args[0] is the command, the rest is its arguments.<br />
*input is the file for input redirection. NULL when no redirection.<br />
*output is the file for output redirection. NULL when no redirection.
</p>
<br />

<b>(2) Compond Command</b>
<pre class='grey'>
typedef struct CompondCmd{
        int isBack;
        SimpleCmd **simCmd;
    } CompondCmd;
</pre>
<p>
Compond Command consists of two parts.<br />
When isBack is 1, it indicates this command will be executed in back end, or in front end.<br />
**simCmd is a series of simple commands. These simple commands make up this compond command.
</p>
<br />

<b>(3) History Commands</b>
<pre class='grey'>
typedef struct History {
        int start;                  
        int end;                   
        int cur;
        char cmds[HISTORY_LEN][100]; 
    } History;
</pre>
<p>
History Commands consists of four parts.<br />
The first three are integers, indicating the starting index, ending index and current index respectively.<br />
cmds{HISTORY_LEN][100] is the array to store history commands, it can store HISTORY_LEN(default 100) commands.
</p>
<br />

<b>(4) Job</b>
<pre class='grey'>
typedef struct Job {
        int pid;         
        char cmd[100];   
        char state[10];  
        struct Job *next;
    } Job;
</pre>
<p>
Each item of job link list has four parts.<br />
pid is the process id.<br />
cmd[100] is the command string.<br/>
state[10] is the state of the job.<br />
*next points to next job on the list.
</p>

			<h5 id="C222">2.2.2 Important Functions and Interfaces</h5>
<b>(1) bison.tab.c</b>
<p>
<b>Function Format</b>: <span>int main(int argc, char** argv)</span><br />
<b>Funtion Functions</b>: <span>Main function</span><br />
<b>Parameters</b>: 
<pre>
	main arguments
</pre>

<b>Function Format</b>: <span>int yylex()</span><br />
<b>Funtion Functions</b>: <span>Lexical analysis</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>void yyerror(const char *s)</span><br />
<b>Funtion Functions</b>: <span>Display lexical errors</span><br />
<b>Parameters</b>: 
<pre>
	const char	*s 			Error Code
</pre>
</p>

<b>(2) init.c</b>
<p>
<b>Function Format</b>: <span>extern void getEnvPath(int len, char *buf)</span><br />
<b>Funtion Functions</b>: <span>Get environment path</span><br />
<b>Parameters</b>: 
<pre>
	int len					Length of buff
	char *buff				File path
</pre>

<b>Function Format</b>: <span>extern void init()</span><br />
<b>Funtion Functions</b>: <span>Initial</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>
</p>

<b>(3) execute.c</b>
<p>
<b>Function Format</b>: <span>int exists(char *cmdFile)</span><br />
<b>Funtion Functions</b>: <span>Judge if a command exist</span><br />
<b>Parameters</b>: 
<pre>
	char *cmdFile	 		Command to be judged
</pre>

<b>Function Format</b>: <span>int str2Pid(char *str, int start, int end)</span><br />
<b>Funtion Functions</b>: <span>Transfer string to integere Pid</span><br />
<b>Parameters</b>: 
<pre>
	char *str				String to be transferred
	int	start				Starting index
	int	end					Ending index
</pre>

<b>Function Format</b>: <span>void justArgs(char *str)</span><br />
<b>Funtion Functions</b>: <span>Adjust format for some external commands</span><br />
<b>Parameters</b>: 
<pre>
	char	*str			Command string
</pre>

<b>Function Format</b>: <span>void release()</span><br />
<b>Funtion Functions</b>: <span>Free environment variables</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>void addHistory(char *cmd)</span><br />
<b>Funtion Functions</b>: <span>Add history records</span><br />
<b>Parameters</b>: 
<pre>
	char	*cmd			Command string to addHistory
</pre>

<b>Function Format</b>: <span>void freeSimpleCmd(SimpleCmd *scmd)</span><br />
<b>Funtion Functions</b>: <span>Free simple command space</span><br />
<b>Parameters</b>: 
<pre>
	SimpleCmd *scmd			Target command
</pre>

<b>Function Format</b>: <span>void freeCompondCmd(CompondCmd *ccmd)</span><br />
<b>Funtion Functions</b>: <span>Free compond command space</span><br />
<b>Parameters</b>: 
<pre>
	CompondCmd *ccmd		Target command
</pre>

<b>Function Format</b>: <span>SimpleCmd* handleSimpleCmdStr(int begin, int end)</span><br />
<b>Funtion Functions</b>: <span>Resolve simple command</span><br />
<b>Parameters</b>: 
<pre>
	int begin				Starting index
	int end					Ending index
</pre>

<b>Function Format</b>: <span>CompondCmd* handleCompondCmdStr(int begin, int end)</span><br />
<b>Funtion Functions</b>: <span>Resolve compond command</span><br />
<b>Parameters</b>: 
<pre>
	int begin				Starting index
	int end					Ending index
</pre>

<b>Function Format</b>: <span>int prepareOutCmd(SimpleCmd *cmd)</span><br />
<b>Funtion Functions</b>: <span>Prepare for execution of external commands</span><br />
<b>Parameters</b>: 
<pre>
	SimpleCmd *cmd			Target simple command pointer
</pre>

<b>Function Format</b>: <span>int execOuterCmd(SimpleCmd *cmd)</span><br />
<b>Funtion Functions</b>: <span>Execute external command</span><br />
<b>Parameters</b>: 
<pre>
	SimpleCmd *cmd			Target simple command pointer
</pre>

<b>Function Format</b>: <span>void execSimpleCmd(SimpleCmd *cmd)</span><br />
<b>Funtion Functions</b>: <span>Execute simple command</span><br />
<b>Parameters</b>: 
<pre>
	SimpleCmd *cmd			Target simple command pointer
</pre>

<b>Function Format</b>: <span>int execCompondCmd(CompondCmd *cmd)</span><br />
<b>Funtion Functions</b>: <span>Execute compond command</span><br />
<b>Parameters</b>: 
<pre>
	CompondCmd *cmd			Target compond command pointer
</pre>

<b>Function Format</b>: <span>void execute(int isSimple)</span><br />
<b>Funtion Functions</b>: <span>Execute command</span><br />
<b>Parameters</b>: 
<pre>
	int isSimple			Indicating if the command is a simple command
</pre>
</p>

<b>(4) handleInBuff.c</b>
<p>
<b>Function Format</b>: <span>int inHistory(int cur)</span><br />
<b>Funtion Functions</b>: <span>Check if the indexed command exists in the history list</span><br />
<b>Parameters</b>: 
<pre>
	int cur					Index for current command
</pre>

<b>Function Format</b>: <span>extern int handleInBuff(void)</span><br />
<b>Funtion Functions</b>: <span>Handle the input buffer, listen to up down arrows and tab key</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>
</p>

<b>(5) handleJob.c</b>
<p>
<b>Function Format</b>: <span>extern Job* addJob(pid_t pid)</span><br />
<b>Funtion Functions</b>: <span>Add new job</span><br />
<b>Parameters</b>: 
<pre>
	pid_t pid				Process ID.
</pre>

<b>Function Format</b>: <span>extern void rmJob(int sig, siginfo_t *sip, void* noused)</span><br />
<b>Funtion Functions</b>: <span>Remove a job</span><br />
<b>Parameters</b>: 
<pre>
	int sig					Signal
	siginfo_t *sip			Signal Information
</pre>
</p>

<b>(6) handleSignal.c</b>
<p>
<b>Function Format</b>: <span>extern void ctrl_Z()</span><br />
<b>Funtion Functions</b>: <span>Implement Ctrl+Z</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>extern void ctrl_C()</span><br />
<b>Funtion Functions</b>: <span>Implement Ctrl+C</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>extern void fg_exec(int pid)</span><br />
<b>Funtion Functions</b>: <span>fg command</span><br />
<b>Parameters</b>: 
<pre>
	int pid					Process ID.
</pre>

<b>Function Format</b>: <span>extern void bg_exec(int pid)</span><br />
<b>Funtion Functions</b>: <span>bg command</span><br />
<b>Parameters</b>: 
<pre>
	int pid					Process ID.
</pre>

<b>(7) search.c</b>
<p>
<b>Function Format</b>: <span>void cleanTab()</span><br />
<b>Funtion Functions</b>: <span>Clear buffer for tab</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>void sortrecommend()</span><br />
<b>Funtion Functions</b>: <span>Sort the matching commands</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>extern int tabFile(void)</span><br />
<b>Funtion Functions</b>: <span>Implement Tab</span><br />
<b>Parameters</b>: 
<pre>
	No parameters.
</pre>

<b>Function Format</b>: <span>int WildCharMatch(char *src, char *pattern, int ignore_case)</span><br />
<b>Funtion Functions</b>: <span>Compare string with wildcards</span><br />
<b>Parameters</b>: 
<pre>
	char *src				Original string
	char *pattern			String with wildcards
	int	ignore_case			if ignore case
</pre>

<b>Function Format</b>: <span>extern void getRegex(int *b, int *e, char *path)</span><br />
<b>Funtion Functions</b>: <span>Find the shortest path string with no space between b and e</span><br />
<b>Parameters</b>: 
<pre>
	int *b					Starting position of search part in path
	int *e					Ending position of search part in path
	char *path				String needing to search wildcards
</pre>

<b>Function Format</b>: <span>extern void regexChange(char *origin, char *newarg, unsigned char d_type)</span><br />
<b>Funtion Functions</b>: <span>Replace original string with matching item</span><br />
<b>Parameters</b>: 
<pre>	
	char *origin			Original string
	char *newarg			Replaced string
	unsigned char d_type	Type for matching file
</pre>

<b>Function Format</b>: <span>extern int regexNum(char *origin)</span><br />
<b>Funtion Functions</b>: <span>Get the number of wildcards</span><br />
<b>Parameters</b>: 
<pre>
	char *origin			Original string
</pre>

<b>Function Format</b>: <span>extern int regexNewArgs(char *origin, char **args, int *index){</span><br />
<b>Funtion Functions</b>: <span>Find matching item, replace original string</span><br />
<b>Parameters</b>: 
<pre>
	char *origin			Original string
	char **args				Store new arguments
	int *index				The argument No. index
</pre>
</p>


			<h5 id="C223">2.2.3 Function Call Graph</h5>
			<img src="{{ site.url }}images/linux_1/20.jpg"  alt="" />
			
			<h3 id="C3">3 Test and Use Instruction</h3>
			<h4 id="C31">3.1 Use</h4>
			<h4 id="C32">3.2 Test</h4>			
		</div>
	</div>
</div>
